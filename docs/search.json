[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Solutions to Advent of code by Eric Wastl.\n\n\n\nvia GIPHY"
  },
  {
    "objectID": "2023/qmd/day09.html",
    "href": "2023/qmd/day09.html",
    "title": "Day 09",
    "section": "",
    "text": "head(txt)\n\n[1] \"13 9 1 2 50 233 728 1871 4300 9258 19218 39107 78571 155948 304911 585118 1098671 2014751 3605471 6296784 10739208\"       \n[2] \"16 39 84 173 354 719 1433 2795 5379 10350 20134 39782 79679 160823 324893 652941 1299026 2548741 4917680 9311783 17280520\"\n[3] \"0 14 39 74 117 165 221 322 616 1545 4242 11327 28389 66554 146616 305124 602288 1130037 2015139 3405883 5420809\"          \n[4] \"6 14 26 55 130 298 626 1203 2142 3582 5690 8663 12730 18154 25234 34307 45750 59982 77466 98711 124274\"                   \n[5] \"15 27 57 112 193 306 501 952 2094 4836 10868 23071 46018 86517 154090 261201 422937 655705 974331 1386730 1885055\"        \n[6] \"4 12 28 52 84 124 172 228 292 364 444 532 628 732 844 964 1092 1228 1372 1524 1684\"                                       \n\n\n\nPart IPart II\n\n\nContinue series of numbers by differencing. Add one more element and submit sum of these extrapolated values.\n\nR (HW)Python\n\n\n\nlapply(\n  txt\n  , FUN = \\(i){\n    # i = txt[1]\n    l = strsplit(i, split = \" \")[[1]] |&gt; \n      as.integer() |&gt; \n      list()\n    \n    while (sum(abs(l[[1]])) &gt; 0L){\n      l = c(list(diff(l[[1]])), l)\n    }\n\n    incr = integer(length(l))\n    incr[1] = 0\n    \n    for (k in seq_along(l)){\n      l[[k]] = c(l[[k]], l[[k]][length(l[[k]])] + incr[k])\n      incr[k + 1] = l[[k]][length(l[[k]])]\n    }\n    \n    l[[length(l)]][length(l[[length(l)]])]\n     \n  }\n  \n) |&gt; \n  unlist() |&gt; \n  sum()\n\n[1] 1987402313\n\n\n\n\n\n\n\n\n\n\nAdd \\(m\\) successive cards where \\(m\\) is the number of matches in a card. Get the final number of cards.\n\nRPython"
  },
  {
    "objectID": "2023/qmd/day04.html",
    "href": "2023/qmd/day04.html",
    "title": "Day 04",
    "section": "",
    "text": "head(txt)\n\n[1] \"Card   1: 44 22 11 15 37 50  3 90 60 34 | 35 60 76  3 21 84 45 52 15 72 13 31 90  6 37 44 34 53 68 22 50 38 67 11 55\"\n[2] \"Card   2: 42 14 40 24 51 49 47 73 34 74 | 40 22 48 65 34 81 24 97 14 49  1 98 66 42 71 74 28 11 47  3 45 63 73 51 87\"\n[3] \"Card   3: 16 48 80 51 41 87 46 77 23  8 | 10 77 41 46  8 36 85 16 87 27 97 13 15 35 45 80 63 37 29 60 48 51 82 61 23\"\n[4] \"Card   4: 82 88 65 64 33 89 23 49 11 92 | 11 33 91 15 81 44 29 27 63 23  1 13 74 89 88  8 37 22 51 92 65  7 49 82 64\"\n[5] \"Card   5: 36 61 30 42 64 45 80 26 84 60 | 50 46 76  4 12 32 38 23 36 45 44 61 53 94 37 33 11 82 84 87 26 19 93 15 98\"\n[6] \"Card   6: 75 63 86 49 17 26 59 70 18 57 | 87  3  2 47 65 21 24 74 28 17 34 33 16 29 63 14 60 95 83 15 41 70 56 49 23\"\n\n\n\nPart IPart II\n\n\nCount the number of winning cards \\(w\\) and return a score \\(s\\), defined as \\[s=\\begin{cases}\n0, \\text{ if } w = 0 \\\\\n2^{w-1}, \\text{ if } w &gt; 0\n\\end{cases}\\]\n\nR (HW)Python\n\n\n\nmatches = function(x){\n  \n  spl = strsplit(x, split = \"\\\\|\")[[1]]\n  pairs = lapply(\n    1:2\n    , FUN = \\(i){\n      strsplit(spl[i], split = \" \")[[1]] |&gt; \n        as.integer() |&gt; \n        na.omit()\n    }\n  )\n  \n  sum(pairs[[2]] %in% pairs[[1]])\n  \n}\n\ntxt = gsub(\"^.*?:\", \"\", txt) \n\nm = Map(\n  matches\n  , x = txt\n) |&gt; \n  unname() |&gt; \n  unlist() \n\nsum(2^(m[m&gt;0] -1L))\n\n[1] 21105\n\n\n\n\n\n\n\n\n\n\nAdd \\(m\\) successive cards where \\(m\\) is the number of matches in a card. Get the final number of cards.\n\nRPython\n\n\n\nmove = function(\n    x\n    , deck\n){\n  if (x &gt; 0){\n    idx = as.integer(names(x))\n    from = min(length(deck), idx + 1L)\n    to = min(length(deck), idx + x)\n    deck[from:to]\n  }\n}\n\nplay = function(\n    game\n    , deck\n){\n\n  i = 0L\n  \n  # while (length(game) &gt; 0L){\n  #   new = move(game[1L], deck = deck)\n  #   game = c(game[-1L], new)\n  #   i = i + 1L\n  #   print(i)\n  # } \n  \n  return(i)\n  \n  # if (length(game) &gt; 0L){\n  #   new = move(game[1L], deck = deck)\n  #   game = c(game[-1L], new)\n  #   play(game, deck = deck)\n  # } else {\n  #   return(idx)\n  # }\n    \n}\n\nnames(m) = 1:length(m)\nnames(deck) = 1:length(m)\nplay(m[1], deck = m)\ngame = m[1:2]\n\n\naddcards = function(x, org){\n  \n  lapply(\n    1:length(x)\n    , FUN = \\(i){\n      i = 1\n      if (x[i] &gt; 0) {\n        idx = as.integer(names(x[i]))\n        org[(idx+1):(idx+org[idx])]\n      }\n    }\n  ) |&gt; \n    unlist()\n  \n  if (length(x) &gt; 0){\n    return(addcards(x, org = org))\n  } else {\n    return(c(org, x))\n  }\n  \n}\n\nnames(m) = 1:length(m)\norg = m\nx = m\naddcards(m, org = m)"
  },
  {
    "objectID": "2023/qmd/day02.html",
    "href": "2023/qmd/day02.html",
    "title": "Day 02",
    "section": "",
    "text": "head(txt)\n\n[1] \"Game 1: 1 green, 2 blue; 15 blue, 12 red, 2 green; 4 red, 6 blue; 10 blue, 8 red; 3 red, 12 blue; 1 green, 12 red, 8 blue\"     \n[2] \"Game 2: 5 green, 2 red, 18 blue; 18 blue, 6 red, 9 green; 6 blue, 3 green; 6 green, 1 red, 9 blue; 19 blue, 2 green, 6 red\"    \n[3] \"Game 3: 16 red, 10 green; 12 red, 6 blue, 9 green; 10 green, 5 blue; 10 green, 16 red; 5 red, 8 green, 8 blue\"                 \n[4] \"Game 4: 9 blue, 20 green; 1 red, 3 blue, 10 green; 7 blue, 18 green; 4 blue, 20 green; 8 blue, 1 green, 1 red; 1 green\"        \n[5] \"Game 5: 3 green, 8 red; 1 blue, 10 red; 6 red, 4 green; 8 red, 1 blue, 3 green; 1 blue, 4 green, 3 red; 1 green, 1 blue, 4 red\"\n[6] \"Game 6: 7 green, 15 red, 11 blue; 2 red, 12 blue; 11 red, 11 green\"                                                            \n\n\n\nPart IPart II\n\n\nIdentify the games that are possible if the bag contained\n\n12 red cubes\n13 green cubes\n14 blue cubes\n\nSubmit the sum of the ids.\n\nRPython\n\n\n\ngetcubes = function(\n    x\n    , colors = c(\"red\", \"green\", \"blue\")\n){\n  \n  vapply(\n    colors\n    , FUN = \\(c){\n      v = grep(c, x = x, value = TRUE)\n      v = gsub(c, replacement = \"\", x = v)\n      v = trimws(v)\n      max(0L, as.integer(v))\n    }\n    , FUN.VALUE = integer(1L)\n  )\n  \n}  \n\ntxt = gsub(\"^.*?:\", \"\", txt) \n\nspl = lapply(\n  txt\n  , FUN = strsplit\n  , split = \";|,\"\n) |&gt; \n  lapply(\"[[\", 1)\n\ncnt = Map(\n  getcubes\n  , x = spl\n)\n\nlapply(\n  cnt\n  , FUN = \\(i){\n    all(i &lt;= c(12, 13, 14))\n  }\n) |&gt; \n  unlist() |&gt; \n  which() |&gt; \n  sum()\n\n[1] 2913\n\n\n\n\n\n\n\n\n\n\nSubmit the power of the minimum set of cubes required to play each game.\n\nRPython\n\n\n\nMap(\n  prod\n  , ... = cnt\n) |&gt;\n  unlist() |&gt; \n  sum()\n\n[1] 55593"
  },
  {
    "objectID": "2023/qmd/day01.html",
    "href": "2023/qmd/day01.html",
    "title": "Day 01",
    "section": "",
    "text": "Load and preview the data set.\n\ny = \"2023\"\nd = \"01\"\n\nifl = file.path(\n  here::here()\n  , y\n  , \"data\"\n  , paste0(\"day\", d, \"input\")\n)\n\ntxt = readLines(ifl)\n\nhead(txt, n = 12L)\n\n [1] \"nine92jnhgqzctpgbcbpz\"             \"sevensddvc73three\"                \n [3] \"9986fmfqhdmq8\"                     \"7onexmxbzllfqb\"                   \n [5] \"six777\"                            \"1zbngsixxrfrpr\"                   \n [7] \"threeeight9seven\"                  \"nhds975three6\"                    \n [9] \"ninepgp9\"                          \"22fourninetzfourfsnxjglthreeeight\"\n[11] \"mhcvqmsg7bdj\"                      \"seven67\"                          \n\n\n\nPart IPart II\n\n\nFor each element in the given vector of characters do: * extract the first and the last digit * concatenate to a new number * calculate the sum\n\nRPython\n\n\nApproach: * get indices of all digits per element using gregexpr * get the first and last digit using range * extract the first and last digits using substtr * create the new number and calculate the sum\n\nl = gregexpr(\"[[:digit:]]\", text = txt) |&gt; \n  lapply(FUN = range) \n\nmapply(\n  \\(t, f){\n    paste0(\n      substr(t, f[1], f[1])\n      , substr(t, f[2], f[2])\n    ) |&gt; \n      as.numeric()\n  }\n  , t = txt\n  , f = l\n  , SIMPLIFY = FALSE\n) |&gt; \n  unname() |&gt; \n  unlist() |&gt; \n  sum(na.rm = TRUE)\n\n[1] 54601\n\n\n\n\nApproach: * extract all digits from a string using list comprehension * get the first and last digit by index and concatenate * calculate the sum\n\ndef getdigits(x: str):\n  digit = [i for i in x if i.isdigit()]\n  digit = digit[0] + digit[-1]\n  return int(digit)\n\nsum([getdigits(i) for i in r.txt])\n\n54601\n\n\n\n\n\n\n\nThe task is the same as in part I, but in addition to digits, also written numbers (one, two, three, …) shall be considered. Extract first and last digit and/or first and last written number from each element of a vector of strings and sum up.\n\nRPython\n\n\nApproach: * replace the second character of any written numbers with their digit (e.g.  one -&gt; o1e, two -&gt; t2o, …) * replacing the entire string would cause issues in case of adjacent written numbers like oneight, sevenine * apply the approach from part I\n\nfromto = c(\n  'one' = 'o1e'\n  , 'two' = 't2o'\n  , 'three' = 't3ree'\n  , 'four' = 'f4ur'\n  , 'five' = 'f5ve'\n  , 'six' = 's6x'\n  , 'seven' = 's7ven'\n  , 'eight' = 'e8ght'\n  , 'nine' = 'n9ne'\n)\n\ntxt_digits = Map(\n  stringi::stri_replace_all_fixed\n  , str = txt\n  , pattern = list(names(fromto))\n  , replacement = list(fromto)\n  , vectorize_all = FALSE\n) |&gt; \n  unlist() |&gt; \n  unname()\n\nl = gregexpr(\"[[:digit:]]\", text = txt_digits) |&gt; \n  lapply(FUN = range) \n\nmapply(\n  \\(t, f){\n    paste0(\n      substr(t, f[1], f[1])\n      , substr(t, f[2], f[2])\n    ) |&gt; \n      as.numeric()\n  }\n  , t = txt_digits\n  , f = l\n  , SIMPLIFY = FALSE\n) |&gt; \n  unname() |&gt; \n  unlist() |&gt; \n  sum(na.rm = TRUE)\n\n[1] 54078\n\n\n\n\n\nfromto = {\n  'one': 'o1e'\n  , 'two': 't2o'\n  , 'three': 't3ree'\n  , 'four': 'f4ur'\n  , 'five': 'f5ve'\n  , 'six': 's6x'\n  , 'seven': 's7ven'\n  , 'eight': 'e8ght'\n  , 'nine': 'n9ne'\n}\n\ndef digitstring2digit(x: str, dic: dict):\n  for i, k in enumerate(dic):\n    x = x.replace(k, dic[k])\n  return x\n\ntxt_digits = [digitstring2digit(i, fromto) for i in r.txt]    \n\nsum([getdigits(i) for i in txt_digits])\n\n54078"
  },
  {
    "objectID": "2023/qmd/day01.html#data",
    "href": "2023/qmd/day01.html#data",
    "title": "Day 01",
    "section": "",
    "text": "Load and preview the data set.\n\ny = \"2023\"\nd = \"01\"\n\nifl = file.path(\n  here::here()\n  , y\n  , \"data\"\n  , paste0(\"day\", d, \"input\")\n)\n\ntxt = readLines(ifl)\n\nhead(txt, n = 12L)\n\n [1] \"nine92jnhgqzctpgbcbpz\"             \"sevensddvc73three\"                \n [3] \"9986fmfqhdmq8\"                     \"7onexmxbzllfqb\"                   \n [5] \"six777\"                            \"1zbngsixxrfrpr\"                   \n [7] \"threeeight9seven\"                  \"nhds975three6\"                    \n [9] \"ninepgp9\"                          \"22fourninetzfourfsnxjglthreeeight\"\n[11] \"mhcvqmsg7bdj\"                      \"seven67\"                          \n\n\n\nPart IPart II\n\n\nFor each element in the given vector of characters do: * extract the first and the last digit * concatenate to a new number * calculate the sum\n\nRPython\n\n\nApproach: * get indices of all digits per element using gregexpr * get the first and last digit using range * extract the first and last digits using substtr * create the new number and calculate the sum\n\nl = gregexpr(\"[[:digit:]]\", text = txt) |&gt; \n  lapply(FUN = range) \n\nmapply(\n  \\(t, f){\n    paste0(\n      substr(t, f[1], f[1])\n      , substr(t, f[2], f[2])\n    ) |&gt; \n      as.numeric()\n  }\n  , t = txt\n  , f = l\n  , SIMPLIFY = FALSE\n) |&gt; \n  unname() |&gt; \n  unlist() |&gt; \n  sum(na.rm = TRUE)\n\n[1] 54601\n\n\n\n\nApproach: * extract all digits from a string using list comprehension * get the first and last digit by index and concatenate * calculate the sum\n\ndef getdigits(x: str):\n  digit = [i for i in x if i.isdigit()]\n  digit = digit[0] + digit[-1]\n  return int(digit)\n\nsum([getdigits(i) for i in r.txt])\n\n54601\n\n\n\n\n\n\n\nThe task is the same as in part I, but in addition to digits, also written numbers (one, two, three, …) shall be considered. Extract first and last digit and/or first and last written number from each element of a vector of strings and sum up.\n\nRPython\n\n\nApproach: * replace the second character of any written numbers with their digit (e.g.  one -&gt; o1e, two -&gt; t2o, …) * replacing the entire string would cause issues in case of adjacent written numbers like oneight, sevenine * apply the approach from part I\n\nfromto = c(\n  'one' = 'o1e'\n  , 'two' = 't2o'\n  , 'three' = 't3ree'\n  , 'four' = 'f4ur'\n  , 'five' = 'f5ve'\n  , 'six' = 's6x'\n  , 'seven' = 's7ven'\n  , 'eight' = 'e8ght'\n  , 'nine' = 'n9ne'\n)\n\ntxt_digits = Map(\n  stringi::stri_replace_all_fixed\n  , str = txt\n  , pattern = list(names(fromto))\n  , replacement = list(fromto)\n  , vectorize_all = FALSE\n) |&gt; \n  unlist() |&gt; \n  unname()\n\nl = gregexpr(\"[[:digit:]]\", text = txt_digits) |&gt; \n  lapply(FUN = range) \n\nmapply(\n  \\(t, f){\n    paste0(\n      substr(t, f[1], f[1])\n      , substr(t, f[2], f[2])\n    ) |&gt; \n      as.numeric()\n  }\n  , t = txt_digits\n  , f = l\n  , SIMPLIFY = FALSE\n) |&gt; \n  unname() |&gt; \n  unlist() |&gt; \n  sum(na.rm = TRUE)\n\n[1] 54078\n\n\n\n\n\nfromto = {\n  'one': 'o1e'\n  , 'two': 't2o'\n  , 'three': 't3ree'\n  , 'four': 'f4ur'\n  , 'five': 'f5ve'\n  , 'six': 's6x'\n  , 'seven': 's7ven'\n  , 'eight': 'e8ght'\n  , 'nine': 'n9ne'\n}\n\ndef digitstring2digit(x: str, dic: dict):\n  for i, k in enumerate(dic):\n    x = x.replace(k, dic[k])\n  return x\n\ntxt_digits = [digitstring2digit(i, fromto) for i in r.txt]    \n\nsum([getdigits(i) for i in txt_digits])\n\n54078"
  },
  {
    "objectID": "2023/qmd/day03.html",
    "href": "2023/qmd/day03.html",
    "title": "Day 03",
    "section": "",
    "text": "head(txt)\n\n[1] \"311...672...34...391.....591......828.......................738....................223....803..472..................................714.840.\"\n[2] \".......*...........*.....*...........*........631%...703.......*..12....652.................*.$............368.769*148.................*....\"\n[3] \"....411...........2....837.121........511.745...........*.48.422.@.........@.............311........887......*................457........595\"\n[4] \"........*328...............&..........................144.*...................138............48.......*......682.........@...*.......777....\"\n[5] \".....144.....+........170...................207............813..../.&....139..*.....346........*..147..143.+.....78....536..79........*.....\"\n[6] \"...........828...559.................181...%..........613.......10...928...*...993.+.........758.*.........471...#../...............573.....\"\n\n\n\nPart IPart II\n\n\nSum up numbers next to a symbol.\n\nRPython\n\n\n\ndig = gsub(\"[^[:digit:]]\", replacement = \".\", x = txt)\nsym = gsub(\"[[:digit:]]\", replacement = \".\", x = txt)\nsym = gsub(\"[^\\\\.]\", replacement = \"*\", x = sym) \n\nhead(dig)\nhead(sym)\n\nfor (i in seq_along(sym)){\n  for (j in 1:nchar(sym[1])){\n    i = 2\n    j = 1\n    idx = gregexpr(\"\\\\*\", text = sym[i])[[1]]\n    idx = as.integer(idx)\n    idx = c(idx -1L, idx, idx + 1L)\n    \n    sub = strsplit(dig[i], \"\")[[1]]\n    sub[idx] = gsub(\"\\\\.\", \"*\", sub[idx])\n    \n    if (i &gt; 1) {\n      sub = strsplit(dig[i-1L], \"\")[[1]]\n      sub[idx] = gsub(\"\\\\.\", \"*\", sub[idx])\n    }\n    \n    for (k in -1:1){\n      \n    }\n  }\n}\n\ngregexpr(\"[[:digit:]]\", dig[1:2])\ngregexpr(\"[^\\\\.]\", sym[1:2])\n\nm = Map(\n  strsplit\n  , x = dig\n  , split =\"\"\n) |&gt; \n  lapply(FUN = \"[[\", 1) |&gt; \n  lapply(FUN = as.integer) |&gt; \n  unname() |&gt; \n  unlist() |&gt; \n  matrix(ncol = 140, byrow = T)\n\nm[1,]\ndig[1]\n\nidx = gregexec(\"\\\\*\", sym) |&gt; \n  lapply(FUN = as.numeric)\n\nm = matrix(\n  rep(0L, times = length(sym) * nchar(sym[1]))\n  , nrow = length(sym)\n)\n\nregexec(\"\\\\*\", text = sym[2])\ngregexec(\"\\\\*\", text = sym[2])\n\nlapply(\n  sym\n  seq_along(sym)\n  , FUN = \\(i){\n    m[i, grep(\"*\", x = sym[i])] = 1L\n  }\n)\n\n\n\n\n\n\n\n\n\n\nRPython"
  },
  {
    "objectID": "2023/qmd/day07.html",
    "href": "2023/qmd/day07.html",
    "title": "Day 07",
    "section": "",
    "text": "Part IPart II\n\n\nRank hands of cards and get the total winnings (bid * rank).\n\nhead(txt, n = 12L)\n\n [1] \"9A35J 469\" \"75T32 237\" \"6T8JQ 427\" \"3366A 814\" \"K2AK9 982\" \"J8KTT 9\"  \n [7] \"94936 970\" \"Q8AK9 15\"  \"3QQ32 940\" \"65555 484\" \"8K88K 674\" \"Q67T5 788\"\n\n\n\nR (HW)R (TA)Python (HW)\n\n\n\ntypes = c(\n  \"11111\" = \"1_highcard\"\n  , \"1112\" = \"2_onepair\"\n  , \"122\" = \"3_twopair\"\n  , \"113\" = \"4_threeofakind\"\n  , \"23\" = \"5_fullhouse\"\n  , \"14\" = \"6_fourofakind\"\n  , \"5\" = \"7_fiveofakind\"\n)\n\nvalues = c(\n  \"A\" = 14\n  , \"K\" = 13\n  , \"Q\" = 12\n  , \"J\" = 11\n  , \"T\" = 10\n  , \"9\" = 9\n  , \"8\" = 8\n  , \"7\" = 7\n  , \"6\" = 6\n  , \"5\" = 5\n  , \"4\" = 4\n  , \"3\" = 3\n  , \"2\" = 2\n)\n\nhandtable = function(x){\n  table(x) |&gt; \n    sort() |&gt; \n    paste(collapse = \"\")\n}\n\nhandtype = function(x, typ = types){\n  \n  h = strsplit(x, split = \"\")\n  h = Map(\n    handtable\n    , x = h\n  ) |&gt; \n    unlist()\n  \n  typ[\n    match(\n      h\n      , table = names(typ)\n    )\n  ] |&gt; \n    unname()\n  \n}\n\nsecondorder = function(x, val = values){\n  \n  h = strsplit(x, split = \"\")\n  h = lapply(\n    h\n    , FUN = \\(i) {\n      unname(\n        val[\n          match(\n            i\n            , table = names(val)\n          )\n        ]\n      )\n    }\n  )\n  \n  lapply(\n    h\n    , FUN = \\(i) {\n      as.numeric(\n        (i / 10) %*% c(100000000, 1000000, 10000, 100, 1)\n      )\n    }\n  ) |&gt; \n    unlist()\n  \n}\n\ndata = data.table(\n  txt = txt\n)\n\ndata[, hand := tstrsplit(txt, split = \" \", keep = 1L)]\ndata[, score := tstrsplit(txt, split = \" \", keep = 2L)]\ndata[, score := as.integer(score)]\ndata[, type := handtype(hand)]\ndata[, sorder := secondorder(hand)]\n\nsetorder(data, type, sorder)\n\ndata[, rank := .I]\ndata[, bid := rank * score]\nsum(data$bid)\n\n[1] 250120186\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhead(txt, n = 12L)\n\n [1] \"9A35J 469\" \"75T32 237\" \"6T8JQ 427\" \"3366A 814\" \"K2AK9 982\" \"J8KTT 9\"  \n [7] \"94936 970\" \"Q8AK9 15\"  \"3QQ32 940\" \"65555 484\" \"8K88K 674\" \"Q67T5 788\"\n\n\n\nR (HW)Python (HW)"
  },
  {
    "objectID": "2023/qmd/day16.html",
    "href": "2023/qmd/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "head(txt)\n\n[1] \"\\\\........-.........\\\\................................|..................-.............\\\\../......-..............\" \n[2] \"........|....\\\\.../...-...............\\\\.........\\\\...........-......-.......\\\\...../.....................-.../...\"\n[3] \".......--.......|.-..-..........................\\\\....../..../........-............/.........|........|........\"   \n[4] \".................................../.........................|....|.....\\\\............./..........|...../..\\\\\\\\..\" \n[5] \".........\\\\................|..../.........................................-......|........................|....\"   \n[6] \".|............-....|.....-.....|...............-.............-....................................\\\\...........\"   \n\n\n\nPart IPart II\n\n\nDetermine number of energized cells.\n\nR (HW)Python\n\n\n\n# txt |&gt; sapply(nchar) |&gt; unname()\n# gsub(\"\\\\\\\\\", \"%%\", x = txt) |&gt; sapply(nchar) |&gt; unname()\n\ngetcell = function(\n    row\n    , col\n    , lines = txt\n){\n  \n  if (!(row %in% 1:length(txt) & col %in% 1:nchar(lines[1]))){\n    s = NA_character_\n  } else {\n    s = substr(lines[row], start = col, stop = col)\n  }\n  \n  return(s)\n  \n}\n\ngetcell(0, 1)\ngetcell(5, 1120)\ngetcell(1, 1)\ngetcell(1, 2)\ngetcell(1, 10)\n\n\nnextcells = function(\n    x\n    , y\n    , from = c(\"l\", \"r\", \"t\", \"b\")\n){\n  \n  from = match.arg(from)\n  type = getcell(x, col = y)\n  \n  if (type == \".\"){\n    if (from == \"l\") n = c(x, y + 1L)\n    else if (from == \"r\") n = c(x, y - 1L)\n    else if (from == \"t\") n = c(x + 1L, y)\n    else if (from == \"b\") n = c(x - 1L, y)\n  } else if (type == \"/\"){\n    if (from == \"l\") n = c(x - 1L, y)\n    else if (from == \"r\") n = c(x + 1L, y)\n    else if (from == \"t\") n = c(x, y - 1L)\n    else if (from == \"b\") n = c(x, y + 1L)\n  } else if (type == \"\\\\\"){\n    if (from == \"l\") n = c(x + 1L, y)\n    else if (from == \"r\") n = c(x - 1L, y)\n    else if (from == \"t\") n = c(x, y + 1L)\n    else if (from == \"b\") n = c(x, y - 1L)\n  } else if (type == \"-\"){\n    if (from == \"l\") n = c(x, y + 1L)\n    else if (from == \"r\") n = c(x, y - 1L)\n    else if (from == \"t\") n = c(x, y + 1L, x, y - 1L)\n    else if (from == \"b\") n = c(x, y + 1L, x, y - 1L)\n  } else if (type == \"|\"){\n    if (from == \"l\") n = c(x + 1L, y, x - 1L, y)\n    else if (from == \"r\") n = c(x + 1L, y, x - 1L, y)\n    else if (from == \"t\") n = c(x + 1L, y)\n    else if (from == \"b\") n = c(x - 1L, y)\n  }\n  \n  n = matrix(n, ncol = 2L, byrow = TRUE)\n  \n  idx = apply(\n    n\n    , MARGIN = 2L\n    , FUN = \\(i) which(i == 0)\n  ) |&gt; \n    unlist()\n  \n  if (length(idx) &gt; 0L) n = n[-idx, , drop = FALSE]\n  return(n)\n  \n}\n\nm = matrix(nrow = 0L, ncol = 2L)\ncolnames(m) = c(\"row\", \"col\")\n\nn = matrix(c(1L, 1L), ncol = 2L, byrow = TRUE)\ncolnames(n) = c(\"row\", \"col\")\n\nwhile (dim(n)[1] &gt; 0L){\n  \n  m = rbind(m, n)\n  \n  for (i in 1:dim(n)[1]){\n    n = nextcells(n[i, ])\n  }\n  \n}\nrbind(\n  m\n  , nextcells(m[])\n)\n\ntxt[1]\nx = 1\ny = 10\nfrom = \"r\"\ngetcell(x, y)\n\nnextcells(1, y = 1, from = \"l\")\nnextcells(1, y = 1, from = \"r\")\nnextcells(1, y = 10, from = \"l\")\nnextcells(1, y = 10, from = \"r\")\nnextcells(1, y = 10, from = \"b\")\nnextcells(1, y = 53, from = \"r\")\nnextcells(1, y = 53, from = \"t\")\nnextcells(1, y = 53, from = \"b\")\nnextcells(1, y = 53, from = \"l\")\n\n\n\n\n\n\n\n\n\nAdd \\(m\\) successive cards where \\(m\\) is the number of matches in a card. Get the final number of cards.\n\nRPython"
  }
]